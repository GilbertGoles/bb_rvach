import asyncio
import re
from typing import List, Dict, Any

class VulnerabilityScanner:
    def __init__(self, rate_limit: int = 3):
        self.rate_limit = rate_limit
        self.name = "vulnerability_scanner"
        self.vulnerability_db = self.load_vulnerability_db()
    
    def load_vulnerability_db(self) -> Dict[str, List[Dict]]:
        """База данных уязвимостей"""
        return {
            "nginx": [
                {
                    "cve": "CVE-2021-23017",
                    "version_range": "<1.20.1",
                    "description": "Уязвимость в обработке DNS",
                    "cvss": 7.5,
                    "exploit_available": True
                }
            ],
            "apache": [
                {
                    "cve": "CVE-2021-41773",
                    "version_range": "2.4.49",
                    "description": "Path Traversal уязвимость",
                    "cvss": 9.8,
                    "exploit_available": True
                }
            ],
            "openssh": [
                {
                    "cve": "CVE-2023-38408",
                    "version_range": "<9.3",
                    "description": "Уязвимость в SSH аутентификации",
                    "cvss": 6.8,
                    "exploit_available": False
                }
            ],
            "ftp": [
                {
                    "cve": "CVE-2020-0000",
                    "version_range": "all",
                    "description": "Анонимный доступ разрешен",
                    "cvss": 5.0,
                    "exploit_available": True
                }
            ]
        }
    
    async def scan(self, services_data: Dict[str, Any]) -> Dict[str, Any]:
        results = {"vulnerabilities": [], "module": self.name}
        
        for host, services in services_data.items():
            for service_info in services:
                vulns = await self.check_service_vulnerabilities(service_info)
                if vulns:
                    results["vulnerabilities"].extend(vulns)
            
            await asyncio.sleep(1 / self.rate_limit)
        
        return results
    
    async def check_service_vulnerabilities(self, service_info: Dict) -> List[Dict]:
        """Проверка уязвимостей для конкретного сервиса"""
        vulnerabilities = []
        service_name = service_info.get('service', '').lower()
        banner = service_info.get('banner', '').lower()
        port = service_info.get('port', 0)
        
        # Проверка анонимного FTP доступа
        if port == 21 and "ftp" in service_name:
            if await self.check_anonymous_ftp(service_info):
                vulnerabilities.append({
                    "type": "anonymous_ftp",
                    "severity": "medium",
                    "cvss": 5.0,
                    "description": "Анонимный FTP доступ разрешен",
                    "service": service_info,
                    "exploit": "ftp_anonymous_login"
                })
        
        # Проверка версий ПО на известные уязвимости
        version = self.extract_version(banner, service_name)
        if version and service_name in self.vulnerability_db:
            for vuln in self.vulnerability_db[service_name]:
                if self.is_version_vulnerable(version, vuln["version_range"]):
                    vulnerabilities.append({
                        "type": "cve_vulnerability",
                        "cve": vuln["cve"],
                        "severity": self.cvss_to_severity(vuln["cvss"]),
                        "cvss": vuln["cvss"],
                        "description": vuln["description"],
                        "service": service_info,
                        "version": version,
                        "exploit_available": vuln["exploit_available"]
                    })
        
        # Проверка HTTP уязвимостей
        if port in [80, 443, 8080, 8443]:
            http_vulns = await self.check_http_vulnerabilities(service_info)
            vulnerabilities.extend(http_vulns)
        
        return vulnerabilities
    
    async def check_anonymous_ftp(self, service_info: Dict) -> bool:
        """Проверка анонимного FTP доступа"""
        try:
            from ftplib import FTP
            ftp = FTP()
            ftp.connect(service_info['host'], service_info['port'], timeout=5)
            ftp.login('anonymous', 'anonymous@example.com')
            ftp.quit()
            return True
        except:
            return False
    
    async def check_http_vulnerabilities(self, service_info: Dict) -> List[Dict]:
        """Проверка HTTP уязвимостей"""
        vulns = []
        host = service_info['host']
        port = service_info['port']
        
        # Проверка доступности common endpoints
        common_paths = [
            "/.git/", "/.env", "/backup/", "/admin/",
            "/phpinfo.php", "/test/", "/debug/"
        ]
        
        for path in common_paths:
            if await self.check_http_endpoint(host, port, path):
                vulns.append({
                    "type": "exposed_endpoint",
                    "severity": "low",
                    "cvss": 3.5,
                    "description": f"Открытый endpoint: {path}",
                    "service": service_info,
                    "endpoint": path
                })
        
        return vulns
    
    async def check_http_endpoint(self, host: str, port: int, path: str) -> bool:
        """Проверка доступности HTTP endpoint"""
        try:
            import aiohttp
            protocol = "https" if port == 443 else "http"
            url = f"{protocol}://{host}:{port}{path}"
            
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=5)) as session:
                async with session.get(url) as response:
                    return response.status == 200
        except:
            return False
    
    def extract_version(self, banner: str, service: str) -> str:
        """Извлечение версии из баннера"""
        if not banner:
            return ""
        
        version_patterns = {
            "nginx": r"nginx/(\d+\.\d+\.\d+)",
            "apache": r"Apache/(\d+\.\d+\.\d+)",
            "openssh": r"OpenSSH_(\d+\.\d+)",
        }
        
        if service in version_patterns:
            match = re.search(version_patterns[service], banner)
            if match:
                return match.group(1)
        
        return ""
    
    def is_version_vulnerable(self, version: str, version_range: str) -> bool:
        """Проверка, попадает ли версия в уязвимый диапазон"""
        if version_range == "all":
            return True
        
        if version_range.startswith("<"):
            max_version = version_range[1:]
            return self.compare_versions(version, max_version) < 0
        
        return False
    
    def compare_versions(self, v1: str, v2: str) -> int:
        """Сравнение версий"""
        v1_parts = [int(x) for x in v1.split('.')]
        v2_parts = [int(x) for x in v2.split('.')]
        
        for i in range(max(len(v1_parts), len(v2_parts))):
            v1_part = v1_parts[i] if i < len(v1_parts) else 0
            v2_part = v2_parts[i] if i < len(v2_parts) else 0
            
            if v1_part != v2_part:
                return v1_part - v2_part
        
        return 0
    
    def cvss_to_severity(self, cvss: float) -> str:
        """Конвертация CVSS в текстовую severity"""
        if cvss >= 9.0:
            return "critical"
        elif cvss >= 7.0:
            return "high"
        elif cvss >= 4.0:
            return "medium"
        else:
            return "low"
